- 2주차 - 스프링 빈 & 컨테이너
    
    스프링
    
    - 객체지향 원칙을 지키면서 개발할 수 있도록 도와주는 JAVA 기반 백엔드 프레임워크
    
    스프링 부트
    
    - 데이터베이스 설정, 웹서버 연동 등을 편리하게 해주는 도구
    - 스프링 프레임워크로 개발할 때 함께 사용한다
    
    스프링 어플리케이션 구조
    
    - todo list를 GET Method로 요청하면 스프링 부트에 있는 내장 tomcat 서버가 먼저 받는다
    - 내장 tomcat 서버는 스프링 컨테이너에 있는 전용 컨트롤러로 보내주고
    - 전용 컨트롤러는 DB로 부터 데이터를 자바 객체 형식으로 받은 후
    - 프론트엔드에게 알맞은 형식으로 보내주기 위해
    - JSON 컨버터를 거친다. 그 후 다시 내장 tomcat 서버를 통해
    - Todo JSON data 형식으로 data가 반환된다
    
    스프링 빈
    
    - 어플리케이션 전역에서 사용할 공용 객체로
    - 스프링 컨테이너라고 하는 스프링 부트가 제공하는 곳에
    - 빈이라고 명명한 객체들을 저장해주고 필요한 빈을 컨테이너에서 받아 사용한다.
    - 필요한 빈은 스프링 프레임워크가 자동으로 가져다준다
    - 빈을 받으려면 다른 스프링 빈인 객체가 빈을 요구해야하는데
    - 이처럼 빈끼리는 서로가 서로를 필요로 하는 구조로 되어있다.
    
    스프링 빈 저장
    
    - 스프링 빈을 스프링 컨테이너에 저장하는 방법에는 2가지가 있다
    - 설정 파일 작성은 수동으로 등록하는 방법으로 자바 클래스로 설정 파일을 작성하고
    - 클래스에 @Configuration이라는 어노테이션을 남겨 설정파일임을 명시한다.
    - 컴포넌트 스캔은 자동으로 빈을 등록하는 방법으로
    - 빈을 생성할 클래스에 @Component 어노테이션을 사용하면
    - 빈 자동등록의 대상이 된다.
    - 설정클래스에는 @ComponentScan 어노테이션을 사용하면
    - 어플리케이션이 시작할 때 @Component가 붙은 클래스를 자동으로 등록해준다.
    - 그렇다면 컴포넌트 스캔을 할 때 어노테이션을 붙을 config파일이 필요한 것 아닌가?
    - 사실 항상 우리가 쓰는 main함수 안에  @ComponentScan이 들어있어 없어도 괜찮다!
    
    의존성 주입
    
    - A의 기능을 실행하는데 B의 기능이 필요하다면 ‘A는 B에 의존한다’ 라고 한다.
    - Car, Wheel 예시처럼 객체간의 관계에도 위의 의존성이 생긴다.
    - 의존성 주입은 의존하는 객체를 직접 생성하지 않고 밖에서 주입받는 것을 뜻한다.
    - 스프링에서는 컨테이너에 저장된 빈과 빈의 의존성을 프레임워크가 주입하는 것을 뜻한다.
    - 이렇게 되면 필요한 객체, 즉 의존하는 객체를 안에 코딩할 필요가 없기 때문에 유지보수가 좋아진다
    - 이는 SOLID 객체 지향 원칙 중 하나인 OCP원칙을 잘 준수하였다고 할 수 있다.
    - 생성자를 주입하려면 필요한 의존성을 final 키워드를 사용해 추가해 주고,
    - @RequiredArgsConstructor를 사용해 생성자를 추가해주면 된다
    - 필드 주입 방법은 필드에 바로 @Autowired 어노테이션을 사용하면 된다.
    - 필드 주입 방법은 주로 테스트 방법에서 쓴다.
    - 클래스에 @SpringBootTest 어노테이션을 사용하면 모든 빈을 컨테이너에 등록 한 후에 테스트한다.
    - 모든 빈이 컨테이너에 들어있는 상태에서 테스트를 진행해서 원하는 빈을 @Autowired 로 필드주입해서
    - 테스트 할 수 있다.
    
    스프링 Layered Architecture
    
    - 컨트롤러, 서비스, 레포지토리는 스프링 어플리케이션의 영역 , DB는 그 외의 영역
    - 서로의 계층으로 요청할 때는 데이터를 넘길 때 특수한 형태로 넘긴다.
    - 서로 의존성을 가지고 역할을 분담하여 일을 처리한다.
    - 컨트롤러는 API 요청을 받아서 응답을 내보낸다. 서비스 계층과 데이터를 주고받는다.
    - 서비스는 비즈니스 로직이 담기고 레포지토리 계층과 데이터를 주고 받는다.
    - 레포지토리는 DB와 소통하며 데이터를 조작하는 계층이다. 비즈니스 로직을 DB에 적용한다.
    - 위의 3개 계층은 스프링 빈으로 등록해서 객체지향 원칙을 준수하며 관리한다.
